function bin2c(filename, status)

local compile, filename = filename:match"^(+?)(.*)"

local content = compile=="+"
  and string.dump(assert(loadfile(filename)))
  or assert(io.open(filename,"rb")):read"*a"

local function boilerplate(fmt)
  return string.format(fmt,
    status and "("..status.."=" or "",
    filename,
    status and ")" or "",
    status and status.."=" or "",
    filename)
end

local dump do
  local numtab={}; for i=0,255 do numtab[string.char(i)]=("%3d,"):format(i) end
  function dump(str)
    return (str:gsub(".", numtab):gsub(("."):rep(80), "%0\n"))
  end
end

return boilerplate[=[
/* code automatically generated by bin2c -- DO NOT EDIT */
{
/* #include'ing this file in a C program is equivalent to calling
  if (%sluaL_loadfile(L,%q)%s==0) %slua_pcall(L, 0, 0, 0); 
*/
/* %s */
static const unsigned char B1[]={
]=], dump(content), boilerplate[=[

};

 if (%sluaL_loadbuffer(L,(const char*)B1,sizeof(B1),%q)%s==0) %slua_pcall(L, 0, 0, 0);
}
]=]


end

function lua2h(filename)
	local outputf, err = io.open(filename .. '.h', 'w+')
	if not outputf then error(err) end
	outputf:write(bin2c(filename))
end

function make_luaopen_header(filename)
	local modulename = filename:match "([^%.]+)%.lua"
	modulename = modulename:gsub("%.", "_")
	return string.format("int luaopen_%s (lua_State *L)", modulename)
end

function make_luaopen(filename)
	local header_file = filename .. '.h'
	local modulename = filename:match "([^%.]+)%.lua"
	local header = make_luaopen_header(filename)
	return string.format([[%s {
	#include "%s"
	lua_getglobal(L, "%s");
	return 1;
}]], header, header_file, modulename)
end

if not arg then error("argument table does not exist") end
for i, v in ipairs(arg) do
	lua2h(v)
	print(make_luaopen(v))
end